module Main where
import Data.List
import qualified Data.Maybe
import Data.Bits
import Data.Ord
import qualified Data.Maybe as Data
{-
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
-}

-- This whole file is very messy...
main = print 0

getFactors :: Int -> [Int]
getFactors n = n : primeFactors !! n ++ primeFactors !! (n+1)

iSqrt :: Integer -> Integer
iSqrt = floor . sqrt . fromIntegral

gaussianSum :: Int -> Int
gaussianSum n = shift (n * (n+1)) (negate 1)

triangleNums :: [Int]
triangleNums = map gaussianSum [1..]

triangleFactors :: [[Int]]
triangleFactors = map getFactors [1..]

problem :: Int -> Int
problem n = head (Data.Maybe.fromMaybe [0] (find (\x -> (>) (genericLength x) n)  triangleFactors))

primePows :: Int -> [(Int,Int)]
primePows n = [(head x, length x) | x <- group $ getPrimeFactors n]

isPrime n = go 2
  where
    go d
      | d*d > n        = True
      | n `rem` d == 0 = False
      | otherwise      = go (d+1)

primes = 2 : filter isPrime [3,5.. ]

-- Returns the smallest primeFactor of a given number or 0 if the number is 1 or 0
primeFactor :: Int -> Int
primeFactor x = Data.Maybe.fromMaybe 0 nextprime
  where nextprime = find (\p -> x `mod` p == 0) (takeWhile (<= x) primes)


-- Gets all PrimeFactors of the given number
getPrimeFactors :: Int -> [Int]
getPrimeFactors n = map snd (takeWhile (\(x,y) -> y /= 0) (primeFactors n))
  where primeFactors n = tail (iterate nextPrimeFactor (n, 1))
        nextPrimeFactor (x,y) | primeFactor x == 0 = (0,0)
                              | otherwise = (x `div` primeFactor x, primeFactor x)

primeFactors :: [[Int]]
primeFactors = map getPrimeFactors [1..]

primeFacTuples :: [([Int], [Int])]
primeFacTuples = zip primeFactors (tail primeFactors)

numDiv :: Int -> Int
numDiv n = product [k + 1 | (_, k) <- primePows n]

solve :: Int -> Int
solve n = head (dropWhile (\x -> numDiv x <= n) triangleNums)